{"name":"Gravy","tagline":"A native quick-start iOS framework to get your app ideas to version 0.1 in minutes.","body":"# Gravy\r\nGravy is a native quick-start framework for iOS that turns your app ideas into a working Version 0.1 in minutes. Gravy is built with **developer happiness** as Priority Number 1. It takes care of all the boilerplate you've written a thousand times over, letting you focus just on what's cool and original in your next big project.\r\n\r\nSay you want to build Pinterest for recipes. What a great idea! To show you how productive you'll be using Gravy, here's how to get v0.1 off the ground in 9 easy steps and ~20 lines of code.\r\n\r\n## Step 1: Define the model.\r\nWe start by subclassing `GRObject` and creating a normal interface file. No database schemas to be found here!\r\n\r\n*Recipe.h*\r\n\r\n\t@interface Recipe : GRObject\r\n\t\r\n\t@property (strong, nonatomic) NSString *instructions;\r\n\t@property (nonatomic) int prep;\r\n\t\r\n\t@end\r\n\r\n## Step 2: Choose the source.\r\nOur model objects live in a \"source\" which holds all objects of the `Recipe` class. We want to save our recipes to disk, so we'll use a `GRLocalSource`, which handles persistence automatically.\r\n\r\n*Recipe.m*\r\n\r\n\t@implementation Recipe \r\n\t\r\n\t+(id)source \r\n\t{\r\n\t\treturn [GRLocalSource source:self];\r\n\t}\r\n\t\r\n\t@end\r\n\r\n## Step 3: Create a recipe collection.\r\nIn our view controller we want to access all the recipes we've created, so we create a `GRCollection`, a class which fetches `GRObject`.\r\n\r\n*MasterViewController.m*\r\n\t\r\n    self.recipes = [GRCollection collectionWithClass:[Recipe class]];\r\n\r\nThe collection will automatically update whenever we add, update or remove recipes.\r\n\r\n## Step 4: Show a list of recipes.\r\nWe want to present the recipes to the user, so we register the collection with a UITableView.\r\n\r\n    [self registerContentView:self.tableView\r\n            forCollection:self.recipes\r\n         customizeHandler:^(UITableViewCell *cell, Recipe *recipe){ \r\n            cell.textLabel.text = recipe.instructions;\r\n         }\r\n         selectionHandler:^(Recipe *recipe){ \r\n                self.detailViewController.recipe = recipe;\r\n                [self.navigationController pushViewController:self.detailViewController animated:YES];\r\n         }\r\n             \r\nWe'll override UITableViewDelegate/DataSource methods later to customize it, but for the moment, this will populate the table view with the objects in the collection. Any changes to the collection will update the table view as needed.\r\n\r\n## Step 5: Wire up an add button.\r\n\r\nAdding new recipes is as simple as `alloc init` and `save`.\r\n\r\n\t-(void)addButtonPressed\r\n\t{\r\n    \tRecipe *newRecipe = [[Recipe alloc] init];\r\n    \tnewRecipe.prep = 10;\r\n    \t[newRecipe save];\r\n\t}\r\n\r\n## Step 6: Wire up a text view to edit recipes.\r\nYou may want to provide a text view for the user to edit the recipe object. Here it is:\r\n\r\n*DetailViewController.m*\r\n\t    \r\n    [self registerControl:self.instructionView forKeyPath:keypath(self.recipe.instructions)];\r\n\t\r\nThat one line of code is your entire detail view. The `registerControl:forKeyPath:` method binds the text view to the `instructions` property on the `recipe` object. Enter text and it'll be set on the `recipe` object. Change the recipe object and the view will update. Magical!\r\n\r\n## Step 7: Delete recipes.\r\nBack in your `MasterViewController` implement this UITableViewDataSource method to handle deletion:\r\n\r\n\t-(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath \r\n\t{\r\n\t\tif (editingStyle == UITableViewCellEditingStyleDelete) \r\n\t\t{\r\n\t\t\tRecipe *recipe = [self.recipes objectAtIndexPath:indexPath];\t\r\n\t\t\t[recipe remove];\r\n\t\t}\r\n\t}\r\n\r\n## Step 8: Setup a server (optional).\r\nSay we want to fetch recipes from a server. We just need to add a few lines of code to our app:\r\n\r\n*Recipe.h*\r\n\r\n\t@interface Recipe : GRObject <GRRemoteObject> // Add protocol\r\n\r\n*Recipe.m*\r\n\r\n\t+(id)source \r\n\t{\r\n\t\treturn [GRRemoteSource source:self]; // Change source class\r\n\t}\r\n\r\n\t+(NSString *)endpoint \r\n\t{\r\n\t\treturn @\"http://api.myserver.com/recipes\";\r\n\t}\r\n\r\nRails makes it trivial to generate a simple back-end. Type into your terminal:\r\n\r\n\trails new Recipintrest\r\n\trails g scaffold Recipe instructions:string prep:integer\r\n\trails g migrate\r\n\t\r\nand in `recipes_controller#index` change: \r\n    \r\n    Recipe.all\r\n    \r\nto \r\n    \r\n    Recipe.where(\"updated_at > ?\", params[:last_sync])\r\n\r\nFrom here, GRRemoteSource will automatically fetch recipes from the specified URL, serialize the returned JSON data as `Recipe` objects and add those objects to itself. Which will in turn automatically populate your tableView with recipe objects. \r\n\r\n**Note:** GRRemoteSource is a stub at the moment. It will be expanded to provide deep integration with a RESTful backend before the 1.0 release of Gravy.\r\n\r\n## Step 9: Post recipes to the server.\r\nNow we have a back-end set up, let's interact with it. In `DetailViewController` we've added a share button which calls this code:\r\n\r\n\tGRHTTPRequest *request = [GRHTTPRequest request:@\"http://api.myserver.com/recipes\"];\r\n\trequest.HTTPMethod = GRHTTPMethodPost;\r\n\trequest.payload = self.recipe;\r\n\trequest.successHandler = ^(HTTPResponse *response){\r\n\t\tNSLog(@\"Shared!\");\r\n\t};\r\n\t\r\n\t[request load];\r\n\r\n**That's it.** That's about 20 lines of code to build a working CRUD app with a full user interface and server component. This app isn't going to get featured on the App Store, but it's an excellent starting point and it's good enough to pass around to some friends to get some feedback. \r\n\r\nGravy is all about *convention over configuration*. It assumes you want to create a normal app, and you only need to interfere if you have custom needs. This makes it incredibly customizable, and you can learn more by diving into the lightweight, readable and well-documented source code.\r\n\r\n# Installation\r\nDownload the source and add the Gravy folder to a new blank Xcode project to get started, then just `#import \"Gravy.h\"`. An installation script and tutorial are coming soon.\r\n\r\n*Try Gravy and let your ideas run free.*","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}